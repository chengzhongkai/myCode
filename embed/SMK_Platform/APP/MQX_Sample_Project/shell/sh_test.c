/*****************************************************************************/
/* Copyright (c) 2015 SMK Corporation. All rights reserved.                  */
/*****************************************************************************/

#include <mqx.h>
#include <shell.h>

#include <rtcs.h>

#include <stdlib.h>

#include "Config.h"

/*** DEBUG ***/
#include "rand.h"
#include "uuid.h"
#include "base64.h"
//#include "sha1.h"
#include "hash.h"
#include "aes.h"
#include "des.h"
#include "hmac.h"
#include "bignum.h"
#include "tls.h"
/*** DEBUG ***/

static void aes_test(void);
static void des_test(void);
static void des3_test(void);
static void sha256_main(void);
static void sha1_main(void);
static void md5_main(void);

static int compare_arrays(const uint8_t *buf1, const uint8_t *buf2, int len);

static const uint8_t certificate[];

//=============================================================================
static void dump_buf(uint8_t *buf, uint32_t len)
{
	uint32_t cnt;

	for (cnt = 0; cnt < len; cnt ++) {
		printf("%02x ", *buf);
		buf ++;
		if (((cnt + 1) & 15) == 0) printf("\n");
	}
	if ((cnt & 15) != 0) printf("\n");
}

//=============================================================================
static void test_md5(char *str)
{
	Hash_t md5;
	uint8_t digest[MD5_BYTES_SIZE];
	int cnt;
	int len;

	len = strlen(str);

	Hash_Init(&md5, HASH_MD5);
	if (len > 0) {
		Hash_Update(&md5, (uint8_t *)str, len);
	}
	Hash_GetDigest(&md5, digest);

	for (cnt = 0; cnt < MD5_BYTES_SIZE; cnt ++) {
		printf("%02x", digest[cnt]);
	}
	printf("\n");
}

//=============================================================================
static void test_sha1(const uint8_t *buf, int len)
{
	Hash_t sha1;
	uint8_t digest[SHA1_BYTES_SIZE];
	int cnt;

	Hash_Init(&sha1, HASH_SHA1);
	if (len > 0) {
		Hash_Update(&sha1, buf, len);
	}
	Hash_GetDigest(&sha1, digest);

	for (cnt = 0; cnt < SHA1_BYTES_SIZE; cnt ++) {
		printf("%02x", digest[cnt]);
	}
	printf("\n");
}

//=============================================================================
static void test_sha256(const uint8_t *buf, int len)
{
	Hash_t sha256;
	uint8_t digest[SHA256_BYTES_SIZE];
	int cnt;

	Hash_Init(&sha256, HASH_SHA256);
	if (len > 0) {
		Hash_Update(&sha256, buf, len);
	}
	Hash_GetDigest(&sha256, digest);

	for (cnt = 0; cnt < SHA256_BYTES_SIZE; cnt ++) {
		printf("%02x", digest[cnt]);
	}
	printf("\n");
}

//=============================================================================
static void usage(void)
{
	printf("Usage: test [test number]\n   Test Command\n");
}

//=============================================================================
int32_t Shell_test(int32_t argc, char *argv[])
{
	bool print_usage;
	bool short_help = FALSE;

	print_usage = Shell_check_help_request(argc, argv, &short_help);
	if (print_usage) {
		if (short_help) {
			printf("test\n");
		} else {
			usage();
		}
		return (0);
	}

	if (argc != 2) {
		usage();
		return (0);
	}

	int test_no;

	test_no = atoi(argv[1]);

	switch (test_no) {
	case 0:
		// random and crypto function test
		// printf("rand() = %d\n", FSL_GetRandom());

		UUID_t uuid;
		char uuid_str[UUID_STRING_LEN];
		char base64_str[256];
		//SHA1_t sha1;
		Hash_t sha1;
		int cnt;

#if 0
		if (UUID_GetUUID4(&uuid)) {
			if (UUID_GetString(&uuid, uuid_str)) {
				printf("UUID4: %s\n", uuid_str);
			}
		}

		if (Base64_Encode(uuid.bytes, UUID_BYTES_SIZE, base64_str, 256)) {
			printf("base64: %s\n", base64_str);
		}

		strcat(base64_str, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");

		printf("base64 + key: %s\n", base64_str);

		SHA1_Hash(base64_str, sha1);

		for (cnt = 0; cnt < 5; cnt ++) {
			printf("%08X", sha1[cnt]);
		}
		printf("\n");
#endif

		printf("\nthe sample nonce\n");
		Base64_Encode("the sample nonce", 16, base64_str, 256);
		printf("base64: %s\n", base64_str);

		strcat(base64_str, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");

		printf("base64 + key: %s\n", base64_str);

		// SHA1_Hash(base64_str, sha1);
		Hash_Init(&sha1, HASH_SHA1);
		Hash_Update(&sha1, (uint8_t *)base64_str, strlen(base64_str));

		uint8_t digest[SHA1_BYTES_SIZE];

		// SHA1_GetDigest(sha1, digest);
		Hash_GetDigest(&sha1, digest);
		for (cnt = 0; cnt < SHA1_BYTES_SIZE; cnt ++) {
			printf("%02x", digest[cnt]);
		}
		printf("\n");

		if (Base64_Encode(digest, 20, base64_str, 256)) {
			printf("base64: %s\n", base64_str);
		}
		break;

	case 1:
		// MD5 Test
		test_md5("");
		test_md5("a");
		test_md5("abc");
		test_md5("message digest");
		test_md5("abcdefghijklmnopqrstuvwxyz");
		test_md5("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
		test_md5("12345678901234567890123456789012345678901234567890123456789012345678901234567890");

		md5_main();
		break;

	case 2:
		// SHA1 test
		test_sha1(NULL, 0);
		const uint8_t buf1[] = {
			0xb0, 0xf4, 0xcf, 0xb9, 0x39, 0xea, 0x78, 0x5e, 0xab, 0xb7, 0xe7, 0xca, 0x7c, 0x47, 0x6c, 0xdd, 0x9b, 0x22, 0x7f, 0x01, 0x5d, 0x90, 0x53, 0x68, 0xba, 0x00, 0xae, 0x96, 0xb9, 0xaa, 0xf7, 0x20, 0x29, 0x74, 0x91, 0xb3, 0x92, 0x12, 0x67, 0x57, 0x6b, 0x72, 0xc8, 0xf5, 0x8d, 0x57, 0x76, 0x17, 0xe8, 0x44, 0xf9, 0xf0, 0x75, 0x9b, 0x39, 0x9c, 0x6b, 0x06, 0x4c
		};
		test_sha1(buf1, 472 / 8);

		sha1_main();
		break;

	case 3:
		// SHA256 test
		test_sha256(NULL, 0);
		const uint8_t buf2[] = {
			0xd1, 0xbe, 0x3f, 0x13, 0xfe, 0xba, 0xfe, 0xfc, 0x14, 0x41, 0x4d, 0x9f, 0xb7, 0xf6, 0x93, 0xdb, 0x16, 0xdc, 0x1a, 0xe2, 0x70, 0xc5, 0xb6, 0x47, 0xd8, 0x0d, 0xa8, 0x58, 0x35, 0x87, 0xc1, 0xad, 0x8c, 0xb8, 0xcb, 0x01, 0x82, 0x43, 0x24, 0x41, 0x1c, 0xa5, 0xac, 0xe3, 0xca, 0x22, 0xe1, 0x79, 0xa4, 0xff, 0x49, 0x86, 0xf3, 0xf2, 0x11, 0x90, 0xf3, 0xd7, 0xf3
		};
		test_sha256(buf2, 472 / 8);

		sha256_main();
		break;

	case 4:
		// AES/DES/3DES Encrypt/Decrypt Test
		aes_test();
		des_test();
		des3_test();
		break;

	case 5:
		// PRF Test
		const uint8_t premaster[] = {
			0x03, 0x01, 0x87, 0x88, 0x39, 0xB4, 0x16, 0x42, 0x16, 0x79,
			0x8C, 0xB3, 0xD1, 0x51, 0x63, 0x23, 0x69, 0x8E, 0x9F, 0xAC,
			0xCB, 0xA6, 0x0D, 0x69, 0x37, 0x65, 0xC5, 0xFF, 0x84, 0x85,
			0x75, 0x5D, 0x7C, 0xD6, 0x1B, 0x7F, 0x30, 0x3F, 0xE1, 0x29,
			0xFE, 0x35, 0xC5, 0xA7, 0x95, 0x7F, 0xB1, 0x8E
		};
		const uint8_t label_seed[] = {
			'm', 'a', 's', 't', 'e', 'r', ' ', 's', 'e', 'c', 'r', 'e', 't',

			// client random
			0x55, 0x62, 0xDC, 0x26, 0x3E, 0xF6, 0x25, 0xF9,
			0x33, 0xE3, 0x3C, 0x31, 0x23, 0xF5, 0xCC, 0x79,
			0xAB, 0x9F, 0xC7, 0x24, 0xBD, 0x97, 0x09, 0x8D,
			0x4A, 0x6B, 0x92, 0x15, 0x84, 0x88, 0x4E, 0x70,

			// server random
			0x55, 0x62, 0xDC, 0x26, 0x32, 0x78, 0x7B, 0x0B,
			0x0A, 0xD5, 0xB0, 0x44, 0x7A, 0x4E, 0x6F, 0x7B,
			0xD9, 0x75, 0x46, 0x17, 0x1F, 0xAE, 0xED, 0xA9,
			0xFE, 0x11, 0x95, 0x4C, 0x3A, 0xC7, 0x0B, 0x7D
		};
		const uint8_t master_secret[] = {
			0x76, 0xF5, 0xBD, 0x2C, 0x70, 0x46, 0x50, 0xBC,
			0x7B, 0x46, 0x82, 0x88, 0x65, 0xA9, 0xC1, 0x51,
			0x6F, 0xAA, 0x0C, 0xC8, 0x7D, 0x9B, 0xB2, 0x72,
			0x21, 0x68, 0xF1, 0x72, 0xCA, 0x6E, 0x8B, 0xEF,
			0x12, 0x0B, 0xF1, 0xC7, 0xE0, 0x42, 0x1E, 0xBC,
			0x47, 0x8C, 0x77, 0x7B, 0x43, 0x17, 0x29, 0x69
		};

		uint8_t *prf;
		prf = _mem_alloc(48);

		PRF_calc(premaster, 48, label_seed, 13 + 32 + 32, prf, 48);

		{
			int cnt;
			printf("master secret: ");
			for (cnt = 0; cnt < 48; cnt ++) {
				printf("%02x ", prf[cnt]);
			}
			printf("\n");
		}

		if (compare_arrays(prf, master_secret, 48)) {
			printf("Error during PRF testcase\n");
		}
		printf("PRF test completed\n");

		_mem_free(prf);
		break;

	case 6:
		// RSA Test
		const uint8_t mod_buf[] = {
0xcf, 0x94, 0xa1, 0x8b, 0x16, 0x6e, 0xf5, 0xf5,
0xe0, 0xdc, 0xea, 0xce, 0x7c, 0x7b, 0x63, 0x7a,
 0xc1, 0xe8, 0x59,
0x27, 0xdc, 0xf8, 0x0f, 0x18, 0x47, 0x5f, 0x31, 0x16, 0x01, 0x34, 0xcc, 0xb4, 0xd2, 0xe3, 0x7d,
0x62, 0xf1, 0x30, 0x9b, 0x8e, 0xb1, 0xca, 0x3e, 0xc5, 0xf9, 0x57, 0xe9, 0x1c, 0x9a, 0xab, 0x3a,
0x10, 0x9e, 0x7c, 0x5c, 0x3b, 0xb1, 0xa8, 0x70, 0xf6, 0xe0, 0x95, 0xf5, 0x82, 0xb1, 0x33, 0x74,
0x13, 0xd1, 0xb8, 0xb2, 0xa0, 0xb4, 0x21, 0x43, 0x3b, 0xe6, 0x9d, 0xfa, 0x61, 0xb6, 0xef, 0x62,
0xd4, 0xf1, 0x67, 0x3c, 0x06, 0x3e, 0x49, 0x3d, 0x20, 0x8d, 0x6e, 0xf5, 0x90, 0xfd, 0xd5, 0xfa,
0xd8, 0x41, 0x21, 0x52, 0x03, 0x31, 0x15, 0x85, 0x08, 0x76, 0xb1, 0xbe, 0x71, 0x4f, 0x4a, 0xde,
0xa8, 0x62, 0x11, 0x9b, 0x7d, 0xb4, 0x1b, 0xf5, 0x8d, 0x0f, 0x21, 0xd3, 0x4a, 0x7d, 0x43, 0xa2,
0x9b, 0x47, 0x6f, 0xb6, 0x15, 0x3f, 0x53, 0xad, 0xd1, 0x0f, 0xb9, 0xfd, 0xa3, 0xcc, 0xb4, 0xc5,
0xb0, 0x90, 0x13, 0x5b, 0x06, 0x3c, 0x4c, 0xab, 0x5e, 0x9a, 0x55, 0x00, 0x1d, 0x9c, 0x84, 0xa8,
0xa4, 0xf5, 0x11, 0x79, 0x46, 0xb9, 0x1c, 0x87, 0xbf, 0xa6, 0x5d, 0x53, 0x39, 0xf7, 0x04, 0xc5,
0x6c, 0xd1, 0xd4, 0x0c, 0xe9, 0x94, 0xb3, 0x29, 0x49, 0xd7, 0x3b, 0xb5, 0x65, 0xb2, 0xef, 0x85,
0x78, 0x93, 0xc5, 0x0c, 0x9e, 0x97, 0x81, 0x43, 0xab, 0x44, 0x39, 0x41, 0xc7, 0x85, 0x24, 0x8a,
0xf5, 0x3c, 0xd1, 0xb0, 0x53, 0xd3, 0x60, 0xd4, 0x7e, 0x6d, 0x2e, 0x83, 0xa4, 0xe1, 0x96, 0xa0,
0x0b, 0x62, 0xef, 0xdb, 0x39, 0xa4, 0x3a, 0x79, 0x41, 0x89, 0x12, 0x05, 0xe5, 0xe4, 0xb0, 0x2e,
0x52, 0xd4, 0xa3, 0x4e, 0xb7, 0xfa, 0xca, 0xf6, 0x5c, 0x2b, 0xae, 0x92, 0x91, 

		};
		const uint8_t exp_buf[] = { 0x01, 0x00, 0x01 };
		const uint8_t enc_buf[] = {
			0x79, 0x1a, 0x1a, 0xd7, 0x50, 0x2d, 0x1f, 0xd3, 0xe6, 0xac,
			0x10, 0x06, 0x14, 0x4a, 0x47, 0x4c, 0x99, 0x80, 0x76, 0xda, 0x50, 0x37, 0x59, 0xbf, 0xec, 0xa5,
			0xb7, 0x9b, 0xdf, 0x26, 0x7a, 0x11, 0x57, 0x8a, 0x32, 0x55, 0xad, 0x6d, 0xc3, 0x7e, 0x48, 0x3e,
			0x5a, 0x8a, 0xb8, 0xba, 0x57, 0x73, 0x11, 0x93, 0xcd, 0x0a, 0x7c, 0x19, 0x31, 0xac, 0xe2, 0x7b,
			0xe9, 0x48, 0x45, 0xe5, 0x29, 0x22, 0x1d, 0x8c, 0x75, 0x95, 0x0e, 0x12, 0x4c, 0xb4, 0x7a, 0x96,
			0x6d, 0x58, 0xcc, 0x72, 0x82, 0x26, 0xaf, 0x19, 0x4f, 0xe7, 0x69, 0xfe, 0x29, 0xbc, 0x6d, 0xa4,
			0xc1, 0x1b, 0x9c, 0x03, 0x1f, 0x53, 0xf6, 0x6a, 0xb2, 0x59, 0x6d, 0x4b, 0x87, 0xc5, 0x5e, 0xbe,
			0x0a, 0x93, 0x88, 0x3a, 0xa2, 0x94, 0x13, 0x43, 0x11, 0x10, 0xcf, 0x55, 0x5a, 0x74, 0xcc, 0x53,
			0xe2, 0x07, 0x9d, 0x1b, 0x48, 0xe7, 0x1e, 0x7a, 0x97, 0xa9, 0x4d, 0xc6, 0x6d, 0xd6, 0xde, 0xc2,
			0x7b, 0x35, 0xfc, 0x28, 0xe3, 0xb8, 0x01, 0x53, 0x61, 0x39, 0x83, 0xf3, 0x24, 0x0c, 0xdd, 0x24,
			0x71, 0xe2, 0x41, 0x16, 0x63, 0x29, 0x4e, 0xd8, 0x1c, 0x4e, 0xf3, 0x10, 0xf7, 0x69, 0x04, 0x6b,
			0xfd, 0x30, 0x91, 0x72, 0xa1, 0xf9, 0x70, 0xe4, 0x75, 0xfc, 0x9b, 0xa1, 0x6b, 0xfd, 0xe6, 0x43,
			0x39, 0xa9, 0x61, 0x28, 0xe3, 0x0f, 0xa7, 0xa6, 0xf6, 0xdd, 0x2e, 0xaf, 0x7c, 0x33, 0x22, 0x2e,
			0x54, 0x9b, 0x11, 0xbb, 0x40, 0x6d, 0x32, 0x91, 0xa1, 0x62, 0x2f, 0x42, 0xff, 0xce, 0xb8, 0xc0,
			0x22, 0x84, 0xe7, 0x49, 0x5e, 0x9a, 0x31, 0x69, 0xc8, 0x45, 0xb0, 0xe2, 0xfa, 0x15, 0xd5, 0x89,
			0x48, 0x5c, 0xde, 0x4e, 0xf6, 0x7e, 0x09, 0xc9, 0xf3, 0xdc, 0x27, 0x64, 0x4e, 0x89, 0xbf, 0x03,
			0x9f, 0xc3, 0x70, 0x0e, 0x3e, 0x66
		};

		BigNum_t mod, exp, enc, dec;

		BigNum_InitFromBuffer(&mod, mod_buf, 256);
		BigNum_InitFromBuffer(&exp, exp_buf, 3);
		BigNum_InitFromBuffer(&enc, enc_buf, 256);
		// dec, dont need to init

		BigNum_PowMod(&dec, &enc, &exp, &mod);

		printf("RSA: \n");
		for (cnt = 255 /* (dec.len - 1) */; cnt >= 0; cnt --) {
			printf("%02x ", dec.num[cnt]);
		}
		printf("\n");

		BigNum_Free(&mod);
		BigNum_Free(&exp);
		BigNum_Free(&enc);
		BigNum_Free(&dec);

		break;

	case 7:
		uint32_t len;
		uint8_t *ptr;

		len = TLS_GetSignedCertificate(certificate, &ptr);
		printf("signedCertificate (ptr=0x%p, len=%d):\n", ptr, len);
		dump_buf(ptr, len);

		len = TLS_GetEncryptedSignature(certificate, &ptr);
		printf("encryptedSignature (ptr=0x%p, len=%d):\n", ptr, len);
		dump_buf(ptr, len);

		len = TLS_GetPublicKey(certificate, &ptr);
		printf("subjectPublicKey (ptr=0x%p, len=%d):\n", ptr, len);
		dump_buf(ptr, len);
		break;

	case 8:
		TLS_Handle_t *tls;
		const char *http_get = "GET /\r\nHTTP/1.1\r\nHost: 192.168.11.2\r\n\r\n";
		static uint8_t recv_buf[4098];
		uint32_t recv_len;

		uint32_t ipaddr = (192 << 24) | (168 << 16) | (11 << 8) | 4;
		TLS_CipherSuite_t cipher_suites[] = {
			TLS_RSA_WITH_AES_128_CBC_SHA,
			TLS_RSA_WITH_AES_256_CBC_SHA,
			TLS_RSA_WITH_3DES_EDE_CBC_SHA
		};

		bool reconnect = FALSE;
		TLS_SessionInfo_t session_info;

		printf(http_get);

		tls = TLS_CreateHandle(TLS_VER_1_0);
		if (tls != NULL) {
			TLS_SetHostname(tls, ipaddr, TLS_DEFAULT_PORTNO);
			TLS_SetCipherSuites(tls, cipher_suites, 3);

			if (TLS_Connect(tls)) {
				TLS_Send(tls, (uint8_t *)http_get, strlen(http_get));

				while ((recv_len = TLS_Recv(tls,
											recv_buf, 4096)) != RTCS_ERROR) {
					recv_buf[recv_len] = '\0';
					printf(recv_buf);
				}

				TLS_Shutdown(tls);

				if (TLS_GetSessionInfo(tls, &session_info)) {
					reconnect = TRUE;
				}
			}

			TLS_FreeHandle(tls);
		}

		if (reconnect) {
			printf("Reconnect using Session ID & Master Secret\n");

			tls = TLS_CreateHandle(TLS_VER_1_0);
			if (tls != NULL) {
				TLS_SetHostname(tls, ipaddr, TLS_DEFAULT_PORTNO);
				TLS_SetCipherSuites(tls, cipher_suites, 3);

#if 0
				/*** DEBUG ***/
				session_info.session_id[0] = 0x88;
#endif

				TLS_SetSessionInfo(tls, &session_info);

				if (TLS_Connect(tls)) {
					TLS_Send(tls, (uint8_t *)http_get, strlen(http_get));

					while ((recv_len = TLS_Recv(tls,
												recv_buf, 4096)) != RTCS_ERROR) {
						recv_buf[recv_len] = '\0';
						printf(recv_buf);
					}

					TLS_Shutdown(tls);
				}

				TLS_FreeHandle(tls);
			}
		}
		break;

	case 9:
		const uint8_t msg[] = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x03, 0x01, 0x00, 0x10,
			0x14, 0x00, 0x00, 0x0c, 0x91, 0x3a, 0x42, 0x1a, 0x00, 0xa5, 0x5c, 0x5d, 0x68, 0x32, 0xd8, 0x2d
		};
		const uint8_t sec[] = {
			0x75, 0x5c, 0x95, 0xf0, 0x94, 0x5b, 0x48, 0x24,
			0x1a, 0x4e, 0xf8, 0xd2, 0xec, 0x2b, 0x32, 0x7f,
			0x63, 0xfc, 0xd5, 0xcc
		};
		uint8_t mac[20];
		HMAC_hash(HASH_SHA1, sec, 20, msg, 13 + 16, NULL, 0, mac);

		for (cnt = 0; cnt < 20; cnt ++) {
			printf("%02x ", mac[cnt]);
		}
		printf("\n");

		HMAC_hash(HASH_SHA1, sec, 20, msg, 13, &msg[13], 16, mac);

		for (cnt = 0; cnt < 20; cnt ++) {
			printf("%02x ", mac[cnt]);
		}
		printf("\n");
		break;

#if 0  // this library wastes too large memory...
	case 5:
		LINT a = lread("1234567890123456789");
		LINT b = lread("87874318743081");
		LINT c = ladd(a, b);

		uint8_t str[100];
		lwrite(str, c);
		printf("result: %s", str);
		break;
#endif
	}


	return (0);
}




//=============================================================================
// AES Tests
//=============================================================================
/*16-byte multiple*/
unsigned char aes_test_msg[] =\
  "Be that word our sign of parting, bird or fiend! I shrieked upstarting"
  "Get thee back into the tempest and the Nights Plutonian shore!"
  "Leave no black plume as a token of that lie thy soul hath spoken!"
  "Leave my loneliness unbroken! quit the bust above my door!"
  "Take thy beak from out my heart, and take thy form from off my door!"
  "Quoth the raven, Nevermore.  ";


/*FSL: taken from python using pycrypto-2.3*/
unsigned char aes128_encrypted[] = 
{
	0xeb, 0x69, 0xb5, 0xae, 0x7a, 0xbb, 0xb8, 0xee, 0x4d, 0xe5, 0x28, 0x97, 0xca, 0xab, 0x60, 0x65, 
	0x63, 0xf9, 0xe8, 0x4c, 0x7f, 0xda, 0x0a, 0x02, 0x3a, 0x93, 0x16, 0x0d, 0x64, 0x56, 0x5a, 0x86, 
	0xf2, 0xe8, 0x5b, 0x38, 0x1d, 0x31, 0xd7, 0x65, 0x7e, 0x8f, 0x8d, 0x53, 0xc5, 0xa6, 0x0c, 0x5d, 
	0xc5, 0x43, 0x98, 0x3b, 0x49, 0x3a, 0xce, 0x7d, 0xf9, 0xb5, 0xf7, 0x95, 0x47, 0x89, 0xaf, 0xd8, 
	0x2f, 0xbd, 0xa4, 0xd8, 0x7f, 0xb9, 0x13, 0x3a, 0xcd, 0x17, 0xc8, 0xc4, 0xb0, 0x5d, 0xe8, 0xf5, 
	0x19, 0x39, 0x6a, 0x14, 0x1b, 0x1b, 0x78, 0x5e, 0xe0, 0xd6, 0x67, 0x9a, 0x36, 0x17, 0x9c, 0x7a, 
	0x88, 0x26, 0xfd, 0x8f, 0x3d, 0x82, 0xc9, 0xb1, 0x2a, 0x9c, 0xc0, 0xdd, 0xdb, 0x78, 0x61, 0x3b, 
	0x22, 0x5d, 0x48, 0x3c, 0xab, 0x10, 0xd3, 0x5d, 0x0d, 0xa1, 0x25, 0x3e, 0x4d, 0xd6, 0x8e, 0xc4, 
	0x1b, 0x68, 0xbb, 0xa4, 0x2d, 0x97, 0x2b, 0xd6, 0x23, 0xa0, 0xf2, 0x90, 0x8e, 0x07, 0x75, 0x44, 
	0xb3, 0xe2, 0x5a, 0x35, 0x38, 0x4c, 0x5d, 0x35, 0xa9, 0x7c, 0xa3, 0xb6, 0x38, 0xe7, 0xf5, 0x20, 
	0xdc, 0x0e, 0x6c, 0x7c, 0x4b, 0x4f, 0x93, 0xc1, 0x81, 0x69, 0x02, 0xb7, 0x66, 0x37, 0x24, 0x0d, 
	0xb8, 0x9a, 0xa8, 0xd4, 0x42, 0x75, 0x28, 0xe8, 0x33, 0x89, 0x1e, 0x60, 0x82, 0xe9, 0xf6, 0x45, 
	0x72, 0x64, 0x65, 0xd2, 0xcd, 0x19, 0xd9, 0x5e, 0xa2, 0x59, 0x31, 0x82, 0x53, 0x20, 0x35, 0x13, 
	0x76, 0x7f, 0xeb, 0xc3, 0xbe, 0xfa, 0x4a, 0x10, 0x83, 0x81, 0x0f, 0x24, 0x6d, 0xca, 0x53, 0x07, 
	0xb9, 0xe0, 0xb9, 0x5d, 0x91, 0x2d, 0x90, 0x86, 0x5b, 0x9d, 0xaa, 0xcd, 0x28, 0xea, 0x11, 0xfb, 
	0x83, 0x39, 0x9c, 0xf5, 0x3b, 0xd9, 0xef, 0x38, 0xc7, 0xa4, 0xad, 0x47, 0xf2, 0x2d, 0xd6, 0x6b, 
	0x26, 0x28, 0x59, 0xaa, 0x33, 0x01, 0x73, 0xc9, 0x46, 0x97, 0xa3, 0xe5, 0x11, 0x71, 0x66, 0xef, 
	0x1f, 0x0b, 0xbc, 0xe7, 0x4f, 0x8c, 0x79, 0xe2, 0x39, 0x14, 0x85, 0xcd, 0xa9, 0x59, 0xed, 0x78, 
	0x9d, 0x37, 0xf5, 0x46, 0xfc, 0xa9, 0x8a, 0x16, 0x0a, 0x76, 0x58, 0x6d, 0x59, 0x9e, 0x65, 0xbe, 
	0x1b, 0xc2, 0x09, 0xa1, 0xf9, 0x40, 0xab, 0xdb, 0x2e, 0x11, 0x30, 0x29, 0x49, 0x75, 0xf7, 0x74, 
	0xe1, 0xf3, 0x78, 0x97, 0x69, 0x2c, 0x6a, 0x0e, 0x0d, 0xbd, 0x72, 0x3d, 0x75, 0xd6, 0x0a, 0x8c, 
	0xc2, 0x92, 0xd9, 0xb6, 0x46, 0x91, 0xa7, 0xe4, 0x74, 0x71, 0xf5, 0xb4, 0x21, 0x86, 0x18, 0xa8  
};

/*FSL: taken from python using pycrypto-2.3*/
unsigned char aes192_encrypted[] = 
{
        0xb5, 0xb8, 0xe5, 0x87, 0x40, 0x71, 0xdf, 0x48, 0x17, 0xf1, 0xe0, 0xa4, 0x92, 0xf1, 0xcf, 0x78, 
	0xb4, 0xb3, 0x92, 0x42, 0xd6, 0x3b, 0x23, 0x3c, 0xa7, 0x82, 0xcc, 0x6a, 0xa4, 0xf5, 0x52, 0x8e, 
	0xdf, 0x02, 0x14, 0x2d, 0x1d, 0xae, 0x3e, 0x86, 0x87, 0x41, 0x8d, 0xe9, 0x5b, 0x12, 0x38, 0x24, 
	0x7e, 0x46, 0xa7, 0xb1, 0x5f, 0x8a, 0x8f, 0x69, 0xdc, 0x56, 0x8f, 0x37, 0x80, 0x53, 0xff, 0x67, 
	0x67, 0x54, 0xa7, 0x79, 0x2b, 0x7b, 0x66, 0x21, 0x78, 0x80, 0x34, 0x02, 0x18, 0xd7, 0xc0, 0xef, 
	0x05, 0xdb, 0x25, 0x4d, 0x42, 0x05, 0xbb, 0x69, 0x35, 0x63, 0xc1, 0x31, 0xe3, 0x47, 0xc2, 0xde, 
	0x67, 0xfe, 0x9f, 0x60, 0xf6, 0x6c, 0xb5, 0x41, 0x5e, 0x25, 0xa6, 0xec, 0xfe, 0xb0, 0x3e, 0x87, 
	0x61, 0x8e, 0x5c, 0x03, 0x8e, 0x8b, 0x20, 0x74, 0xcd, 0x49, 0xa8, 0x04, 0xb0, 0xca, 0x10, 0xaa, 
	0x27, 0x5d, 0xe7, 0xfe, 0x90, 0x3e, 0x50, 0xe4, 0x3e, 0x94, 0x68, 0xd1, 0xcc, 0x54, 0x28, 0xba, 
	0x2d, 0x2a, 0x88, 0x0d, 0xfa, 0xb2, 0x0a, 0x15, 0x8d, 0x0a, 0xdc, 0xbc, 0x16, 0xd8, 0xaf, 0x1d, 
	0xce, 0x9a, 0xfa, 0x90, 0x96, 0x62, 0xbd, 0x11, 0x62, 0x09, 0x80, 0xfe, 0xbd, 0x6d, 0xca, 0xbc, 
	0x6a, 0x07, 0xf9, 0x5e, 0x63, 0xe2, 0x6d, 0xfe, 0x7d, 0x88, 0xa2, 0xb6, 0x8e, 0xaf, 0x1a, 0x80, 
	0x62, 0x19, 0x4c, 0x68, 0xfc, 0x61, 0x18, 0x58, 0x33, 0x76, 0x20, 0x84, 0x5d, 0xd6, 0x49, 0x97, 
	0xb7, 0x79, 0x83, 0xf0, 0x69, 0x2f, 0xce, 0x73, 0x86, 0x5a, 0x6f, 0xfa, 0x96, 0x66, 0x97, 0xf3, 
	0xa0, 0xb3, 0xed, 0x67, 0x36, 0x64, 0x08, 0x28, 0x75, 0xb5, 0x58, 0x19, 0x85, 0x01, 0x28, 0x3e, 
	0xb1, 0x8e, 0x68, 0x4e, 0x9f, 0x95, 0x86, 0xae, 0xe0, 0x6e, 0x60, 0xbe, 0xa0, 0xfc, 0x5e, 0x8b, 
	0x5e, 0xe8, 0x96, 0xe9, 0xfa, 0xcb, 0x3d, 0xce, 0x9d, 0x70, 0xbe, 0xa2, 0x05, 0x52, 0xbb, 0xa2, 
	0x79, 0xc9, 0xac, 0xf5, 0x91, 0xa2, 0xe4, 0xda, 0xa4, 0x5f, 0x89, 0x75, 0x45, 0x7b, 0x58, 0xe3, 
	0xdb, 0x0f, 0xef, 0xd6, 0xa7, 0x88, 0x9c, 0x0d, 0xf3, 0x5b, 0x49, 0xb1, 0x27, 0xe3, 0x81, 0x92, 
	0x93, 0x91, 0xaf, 0x27, 0x6b, 0x5a, 0x2e, 0x1a, 0x0c, 0xb6, 0xc5, 0x50, 0xc4, 0xb3, 0xf8, 0xfd, 
	0x0a, 0xff, 0xc7, 0x8c, 0x55, 0xde, 0xde, 0x6f, 0x7c, 0xb9, 0xaa, 0x8d, 0x18, 0x17, 0xc5, 0x55, 
	0x95, 0x59, 0xd0, 0x00, 0x53, 0x63, 0xaf, 0xe9, 0xf9, 0xde, 0x93, 0xe2, 0xa6, 0x90, 0xe5, 0xa9  
};

/*FSL: taken from python using pycrypto-2.3*/
unsigned char aes256_encrypted[] = 
{
	0x09, 0x9b, 0xf5, 0xb3, 0xaf, 0x11, 0xa9, 0xd1, 0xa1, 0x81, 0x78, 0x6c, 0x6e, 0x74, 0xf3, 0xb8, 
	0x70, 0xee, 0x31, 0x4d, 0x6d, 0x54, 0xab, 0x37, 0xcb, 0xeb, 0x58, 0x6f, 0x09, 0x5f, 0x72, 0xc4, 
	0x5a, 0xd0, 0x56, 0xc8, 0x3d, 0x93, 0x45, 0xe2, 0x7e, 0x97, 0xaa, 0xc3, 0xc9, 0xf5, 0xde, 0x74, 
	0x73, 0x45, 0x35, 0xea, 0x1f, 0x5e, 0x81, 0xbf, 0x9d, 0xb5, 0xc9, 0x77, 0x77, 0x1c, 0x00, 0xde, 
	0x67, 0x34, 0xff, 0x62, 0x48, 0x89, 0xd9, 0xbe, 0x92, 0xd4, 0x7e, 0xaf, 0x9d, 0x8a, 0x65, 0x14, 
	0x1f, 0x62, 0xaa, 0x0a, 0xe4, 0x37, 0x8e, 0x18, 0x3c, 0x75, 0x5e, 0x38, 0x6a, 0xa9, 0x5d, 0x26, 
	0x54, 0x0a, 0xd8, 0xeb, 0x7a, 0x25, 0xa6, 0xd4, 0x18, 0x13, 0x1f, 0x30, 0xfc, 0x37, 0x09, 0x77, 
	0x90, 0x26, 0x88, 0x0e, 0x53, 0x67, 0xba, 0xe2, 0xfa, 0x38, 0xb9, 0x74, 0xa9, 0x5b, 0xda, 0x6a, 
	0xe0, 0xb3, 0x39, 0xed, 0x07, 0xae, 0xe6, 0x86, 0x44, 0x2d, 0xf2, 0xd8, 0x1f, 0x86, 0x2c, 0xac, 
	0x01, 0x4c, 0x9b, 0xce, 0x65, 0x6a, 0x8a, 0x3a, 0xf0, 0xf9, 0xfd, 0x15, 0x65, 0xb6, 0xaf, 0xdc, 
	0x90, 0xc5, 0x47, 0x96, 0x28, 0xb0, 0x1c, 0x56, 0x2e, 0xc6, 0xdd, 0x4e, 0x71, 0xd3, 0x73, 0xf5, 
	0x7c, 0xa6, 0x66, 0x8b, 0x44, 0xaf, 0x53, 0x61, 0x16, 0xe3, 0x41, 0x94, 0xe7, 0x6d, 0x3d, 0xdb, 
	0xe1, 0x92, 0x52, 0x39, 0x05, 0x97, 0xf4, 0x41, 0xc8, 0xbe, 0x54, 0xec, 0x9a, 0x52, 0xf1, 0x79, 
	0x0c, 0x71, 0x05, 0x14, 0xc8, 0x16, 0x86, 0xdb, 0xa3, 0x8e, 0x1c, 0x41, 0x5b, 0x7a, 0x3b, 0x77, 
	0xa9, 0x27, 0x7a, 0xde, 0xcd, 0xaa, 0x86, 0x2e, 0x52, 0x87, 0x54, 0x1c, 0x88, 0x4c, 0xdb, 0x3e, 
	0xab, 0x48, 0xaa, 0x51, 0x5a, 0xcd, 0xb0, 0xe7, 0x68, 0x91, 0x33, 0x9e, 0xfd, 0x07, 0x9d, 0xdf, 
	0x18, 0x51, 0xa5, 0xc0, 0xa6, 0x68, 0xbc, 0xd2, 0x6b, 0x1f, 0x03, 0xfc, 0xf3, 0x71, 0xed, 0x5b, 
	0x28, 0x35, 0xa8, 0x56, 0x93, 0x4c, 0xdc, 0x1f, 0xa1, 0x88, 0xe8, 0xbe, 0x08, 0x48, 0xe8, 0x28, 
	0x1d, 0x16, 0xb4, 0x1e, 0xeb, 0xca, 0xdd, 0x43, 0x18, 0xfe, 0x49, 0x24, 0xfd, 0x23, 0x83, 0x44, 
	0x2b, 0xc3, 0x33, 0x80, 0x62, 0xb9, 0xa6, 0xb8, 0x48, 0x1e, 0x72, 0x52, 0xef, 0xee, 0x56, 0xd8, 
	0x05, 0x08, 0xad, 0xc2, 0xe9, 0xb7, 0x46, 0x12, 0xbc, 0xc8, 0x7d, 0xe2, 0x87, 0x9d, 0x57, 0xf7, 
	0x6f, 0x10, 0x6e, 0x8c, 0x32, 0x8e, 0x2f, 0x78, 0x20, 0xf0, 0x23, 0x29, 0x54, 0xef, 0x66, 0x8d
};

static int compare_arrays(const uint8_t *buf1, const uint8_t *buf2, int len)
{
	int cnt;
	for (cnt = 0; cnt < len; cnt ++) {
		if (*buf1 != *buf2) break;
		buf1 ++;
		buf2 ++;
	}
	if (cnt == len) return (0);
	return (*buf2 - *buf1);
}

/*after encrypt/decrypt we must have original input: symmetric crypto algorithm*/
/*AES in CBC mode*/
static void aes_test(void)
{
    /*Testing AES support*/
    unsigned int length;  
  
    /*16 bytes key: "ultrapassword123"*/
    unsigned char   key128[128/8] = { 0x75, 0x6c, 0x74, 0x72, 0x61, 0x70, 0x61, 0x73, 
                                         0x73, 0x77, 0x6f, 0x72, 0x64, 0x31, 0x32, 0x33 };
    /*24 bytes key: "UltraMegaSecretPassword1"*/
    unsigned char   key192[192/8] = { 0x55, 0x6c, 0x74, 0x72, 0x61, 0x4d, 0x65, 0x67, 
                                         0x61, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x50, 
	                                     0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x31 };
    /*32 bytes key: "Thispasswordisveryuncommonforher"*/
    unsigned char   key256[256/8] = { 0x54, 0x68, 0x69, 0x73, 0x70, 0x61, 0x73, 0x73, 
                                         0x77, 0x6f, 0x72, 0x64, 0x69, 0x73, 0x76, 0x65, 
	                                     0x72, 0x79, 0x75, 0x6e, 0x63, 0x6f, 0x6d, 0x6d, 
                                         0x6f, 0x6e, 0x66, 0x6f, 0x72, 0x68, 0x65, 0x72 };
                                     
    /*initialization vector: 16 bytes: "mysecretpassword"*/
    unsigned char   ive[AES_BLOCK_SIZE] = { 0x6d,0x79,0x73,0x65,0x63,0x72,0x65,0x74,0x70,0x61,0x73,0x73,0x77,0x6f,0x72,0x64 };
        
    /*result holding the example max length array*/
    unsigned char   output[sizeof(aes_test_msg)-1];
	
    length = strlen((const char *)aes_test_msg);
      
    /************************AES128**************************/
	AES_t aes;
    //encrypt
	AES_Init(&aes, AES_128, key128, ive);
	AES_Encrypt(&aes, aes_test_msg, output, length);

    //compare encrypted info
    if( compare_arrays(output,aes128_encrypted,length) != 0 )
        printf("AES128 encryption error\n\r");
       
    //decrypt
	AES_Init(&aes, AES_128, key128, ive);
	AES_Decrypt(&aes, aes128_encrypted, output, length);

    //compare decrypted info
    if( compare_arrays(output,aes_test_msg,length) != 0)
        printf("AES128 decryption error\n\r");
    
    printf("AES128 test completed\n");
    
    /************************AES192**************************/
    
    //encrypt
	AES_Init(&aes, AES_192, key192, ive);
	AES_Encrypt(&aes, aes_test_msg, output, length);
    
    //compare encrypted info
    if( compare_arrays(output,aes192_encrypted,length) != 0 )
        printf("AES192 encryption error\n\r");
       
    //decrypt
	AES_Init(&aes, AES_192, key192, ive);
	AES_Decrypt(&aes, aes192_encrypted, output, length);

    //compare decrypted info
    if( compare_arrays(output,aes_test_msg,length) != 0)
        printf("AES192 decryption error\n\r");
    
    printf("AES192 test completed\n");
    
    /************************AES256**************************/
    
    //encrypt
	AES_Init(&aes, AES_256, key256, ive);
	AES_Encrypt(&aes, aes_test_msg, output, length);
    
    //compare encrypted info
    if( compare_arrays(output,aes256_encrypted,length) != 0 )
        printf("AES256 encryption error\n\r");
       
    //decrypt
	AES_Init(&aes, AES_256, key256, ive);
	AES_Decrypt(&aes, aes256_encrypted, output, length);

    //compare decrypted info
    if( compare_arrays(output,aes_test_msg,length) != 0)
        printf("AES256 decryption error\n\r");
    
    printf("AES256 test completed\n");
}


//=============================================================================
// DES Tests
//=============================================================================

/*8-byte multiple*/
unsigned char des_test_msg[] =\
  "Once upon a midnight dreary, while I pondered weak and weary,"
  "Over many a quaint and curious volume of forgotten lore,"
  "While I nodded, nearly napping, suddenly there came a tapping,"
  "As of some one gently rapping, rapping at my chamber door"
  "Tis some visitor, I muttered, tapping at my chamber door"
  "Only this, and nothing more.";

/*FSL: taken from http://www.tero.co.uk/des/test.php*/
unsigned char des_encrypted[] = 
{
	0xfa, 0xfe, 0xcd, 0xd1, 0x13, 0x6e, 0x68, 0xf2, 0x12, 0xf7, 0x7a, 0xed, 0x26, 0x7e, 0x03, 0x36, 
	0x56, 0xa8, 0xeb, 0xa1, 0xa3, 0xdf, 0x88, 0x48, 0x31, 0x8e, 0x41, 0x8b, 0x16, 0x0c, 0x3f, 0x2d, 
	0x54, 0xc5, 0x98, 0x67, 0x2e, 0x47, 0xd1, 0x2c, 0xc8, 0x54, 0x29, 0xb4, 0x73, 0xc1, 0xa1, 0x70, 
	0x31, 0x73, 0xc3, 0xb7, 0xbe, 0xd6, 0xc2, 0xb5, 0x71, 0x84, 0xab, 0xe6, 0x62, 0x3a, 0xb0, 0x6f, 
	0x9d, 0xd9, 0x9a, 0xd3, 0x28, 0xd5, 0xfc, 0x61, 0xed, 0x17, 0x09, 0x48, 0xdf, 0x0e, 0xdf, 0xeb, 
	0x29, 0xd0, 0x22, 0x0f, 0x33, 0x49, 0xec, 0x22, 0x6f, 0x53, 0x8e, 0x7d, 0xf2, 0xbd, 0xbe, 0x8b, 
	0x88, 0xbd, 0x9c, 0xd8, 0x5c, 0x1b, 0x3e, 0x1a, 0xc4, 0xf7, 0xf5, 0xe6, 0xf7, 0x8e, 0xd4, 0xa3, 
	0xbf, 0x36, 0xc3, 0x79, 0x2f, 0xd6, 0x2a, 0xff, 0xa3, 0xa9, 0x78, 0x72, 0x1e, 0xf4, 0x36, 0x81, 
	0xe3, 0x9e, 0xe8, 0x03, 0x8a, 0x5c, 0x94, 0xf2, 0xe4, 0x15, 0xbf, 0x6b, 0x1d, 0x85, 0x44, 0x31, 
	0x03, 0x1d, 0x45, 0xba, 0xf2, 0xc0, 0x6e, 0x4c, 0x4f, 0x03, 0xb6, 0xea, 0x35, 0x04, 0xde, 0x38, 
	0xc9, 0x0e, 0x19, 0x34, 0xfa, 0x19, 0xc5, 0xa0, 0x67, 0x54, 0x1f, 0x00, 0xe7, 0x61, 0xbd, 0xba, 
	0x5e, 0xeb, 0xe7, 0x2f, 0x1d, 0x54, 0x3d, 0x26, 0x11, 0x0f, 0x22, 0x4c, 0x1e, 0xb5, 0x3b, 0xaa, 
	0xab, 0x38, 0x48, 0x6e, 0xbf, 0x85, 0xcb, 0x6b, 0x89, 0xda, 0xfd, 0xf3, 0x41, 0x26, 0x1f, 0xfc, 
	0x1a, 0x2e, 0x77, 0xcc, 0x04, 0xe1, 0x53, 0x9f, 0x59, 0x36, 0xa9, 0x27, 0xca, 0x70, 0x83, 0x26, 
	0xcc, 0xe6, 0x0a, 0xf7, 0xe7, 0x2c, 0x7c, 0x31, 0xaa, 0x2e, 0xa7, 0xd9, 0x41, 0x39, 0x8d, 0xb3, 
	0x17, 0x84, 0x2f, 0x27, 0xcf, 0x12, 0x81, 0x8f, 0xb8, 0xf3, 0x05, 0xed, 0xca, 0x30, 0x73, 0xa4, 
	0x5e, 0xe9, 0xd7, 0x54, 0x26, 0xa2, 0x29, 0x68, 0xee, 0x2b, 0x30, 0x94, 0xc2, 0x35, 0x92, 0xc6, 
	0x4d, 0xd1, 0x4c, 0x80, 0xfb, 0x44, 0xc0, 0x3e, 0xc2, 0x5e, 0xa9, 0xe0, 0xe5, 0xfb, 0x62, 0x30, 
	0x0c, 0x0b, 0x95, 0xd5, 0x16, 0xbb, 0x5d, 0xf0, 0x08, 0x9c, 0x42, 0x84, 0xe3, 0x8d, 0x48, 0xd9, 
	0x5c, 0xd8, 0x44, 0x61, 0xc1, 0x07, 0xe2, 0x75, 0x68, 0x75, 0xf9, 0xbc, 0x4d, 0x56, 0x67, 0x98  
};
/*8-byte multiple*/
unsigned char des3_test_msg[] =\
  "And the raven, never flitting, still is sitting, still is sitting"
  "On the pallid bust of Pallas just above my chamber door;"
  "And his eyes have all the seeming of a demons that is dreaming,"
  "And the lamp-light oer him streaming throws his shadow on the floor;"
  "And my soul from out that shadow that lies floating on the floor"
  "Shall be lifted - nevermore!";

/*FSL: taken from http://www.tero.co.uk/des/test.php*/
unsigned char des3_encrypted[] = 
{
	0xb9, 0x30, 0x3f, 0xda, 0x4d, 0x82, 0xc5, 0xe7, 0x27, 0x6b, 0x91, 0xf2, 0x84, 0x15, 0xf9, 0x74, 
	0xd0, 0xe5, 0x5f, 0x4b, 0x95, 0xe1, 0x35, 0xac, 0x5d, 0xbe, 0xa8, 0x83, 0x6d, 0xd5, 0x71, 0x0d, 
	0xde, 0x86, 0x71, 0x61, 0x58, 0x23, 0xe8, 0x4a, 0x3c, 0x99, 0x96, 0x98, 0x00, 0x1a, 0xe7, 0x42, 
	0xd4, 0x72, 0xf2, 0xf9, 0xc5, 0x50, 0xa9, 0x7f, 0xe7, 0xab, 0xee, 0x5a, 0x3b, 0x5b, 0x43, 0x67, 
	0x59, 0x30, 0xec, 0x37, 0xe5, 0x2f, 0xc6, 0x5c, 0x45, 0x02, 0x55, 0xe6, 0x75, 0x11, 0x7c, 0x9d, 
	0x05, 0xa9, 0xe2, 0x97, 0xc8, 0xe3, 0x6a, 0x65, 0x76, 0xce, 0xc3, 0x56, 0xea, 0xd4, 0x30, 0x0d, 
	0xe4, 0x4c, 0x9a, 0xee, 0x9c, 0x5e, 0x48, 0xa3, 0x85, 0x85, 0x5f, 0x59, 0x3b, 0x34, 0xee, 0x32, 
	0x54, 0xd9, 0x91, 0x9f, 0x97, 0x7c, 0xce, 0x1d, 0x9e, 0xe8, 0xb8, 0x86, 0xbc, 0x3a, 0x1e, 0x52, 
	0xe1, 0x35, 0xe3, 0x92, 0xa2, 0xa3, 0xa6, 0xbd, 0x3f, 0x66, 0x76, 0xf3, 0x47, 0x37, 0x61, 0xb8, 
	0x12, 0x35, 0xa1, 0x7e, 0xb3, 0xd1, 0x79, 0xfd, 0xb3, 0x69, 0xbc, 0x68, 0x4c, 0xd2, 0x24, 0xdc, 
	0x04, 0xae, 0x82, 0x0e, 0x54, 0x4b, 0xcf, 0xa8, 0x40, 0xde, 0x72, 0x4c, 0x23, 0xfc, 0xc9, 0x86, 
	0x78, 0xc3, 0x50, 0xf0, 0x1d, 0x62, 0x61, 0x7d, 0xbb, 0xc9, 0x83, 0x6f, 0x21, 0x3f, 0x6f, 0x2a, 
	0xb1, 0x7e, 0x9f, 0x24, 0xee, 0xe7, 0x5b, 0x1d, 0xca, 0xb5, 0xd0, 0x31, 0xdc, 0xc5, 0x95, 0xcf, 
	0x8e, 0x5c, 0xf0, 0xbf, 0xb2, 0x15, 0xfb, 0x68, 0x65, 0xc7, 0x5d, 0x77, 0x17, 0xc2, 0xf2, 0xd7, 
	0x19, 0x29, 0xcb, 0x49, 0x62, 0xf3, 0xa1, 0xd0, 0x18, 0xc1, 0xed, 0x77, 0x9f, 0x4d, 0x28, 0xce, 
	0x66, 0x62, 0x7d, 0x56, 0xe7, 0x11, 0x5f, 0xf1, 0x7a, 0xca, 0xf4, 0x2d, 0xeb, 0x6d, 0xca, 0x47, 
	0xf3, 0x39, 0xfc, 0x2e, 0x81, 0x73, 0x70, 0xe1, 0x4c, 0x37, 0xf8, 0xda, 0x91, 0x79, 0x7c, 0x4b, 
	0xa0, 0xb4, 0x0e, 0x1e, 0xcf, 0x7b, 0xb1, 0xba, 0x9c, 0xe8, 0x8b, 0xcf, 0xe0, 0x7b, 0x07, 0x13, 
	0x17, 0x0d, 0x55, 0xbf, 0x3d, 0x24, 0x6e, 0xfe, 0x61, 0x68, 0x41, 0xaf, 0x23, 0xf4, 0xd6, 0xd7, 
	0xf3, 0xab, 0x78, 0x9c, 0xbf, 0xd3, 0xde, 0x37, 0xe1, 0x0c, 0x02, 0x88, 0xa5, 0xd4, 0x43, 0xf9, 
	0x08, 0x2d, 0x53, 0xce, 0x2e, 0x43, 0xdc, 0x25, 0x26, 0xe1, 0x39, 0x17, 0x60, 0x10, 0x2d, 0x07, 
	0xa5, 0x9e, 0x1c, 0xa6, 0x90, 0x46, 0x68, 0x14
};


/*after encrypt/decrypt we must have original input: symmetric crypto algorithm*/
/*DES in CBC mode*/
static void
des_test(void)
{
    /*Testing DES support*/
    unsigned int length;  
  
    /*8 bytes key: "password"*/
    /*Note: parity is fixed inside DES crypto function*/
#if 0
    unsigned char   key[DES1_KEY_SIZE] = { 0x70,0x61,0x73,0x73,0x77,0x6F,0x72,0x64 };
#else
    unsigned char   key[DES1_KEY_SIZE] = { 0x70, 0xc1, 0xcb, 0x97, 0x6d, 0xdc, 0xb2 };
#endif

    /*initialization vector: 8 bytes: "mysecret"*/
    unsigned char   ive[DES_BLOCK_SIZE] = { 0x6d,0x79,0x73,0x65,0x63,0x72,0x65,0x74 };
        
    /*result holding the example max length array*/
    unsigned char   output[sizeof(des_test_msg)-1];
	
	DES_t des;

	length = strlen((const char *)des_test_msg);
      
	//encrypt
	DES_Init(&des, DES_1, key, ive);
	DES_Encrypt(&des, des_test_msg, output, length);
    
	//compare encrypted info
	if( compare_arrays(output,des_encrypted,length) != 0 )
		printf("DES encryption error\n\r");
       
	//decrypt
	DES_Init(&des, DES_1, key, ive);
	DES_Decrypt(&des, des_encrypted, output, length);

	//compare decrypted info
	if( compare_arrays(output,des_test_msg,length) != 0)
		printf("DES decryption error\n\r");

    printf("DES test completed\n");
}

/*after encrypt/decrypt we must have original input: symmetric crypto algorithm*/
/*3DES in CBC mode*/
static void
des3_test(void)
{
    /*Testing 3DES support*/
    unsigned int length;  
  
    /*24 bytes key: "verynicepassword12345678"*/
    /*Note: parity is fixed inside DES crypto function*/
#if 0
    unsigned char   key[DES3_KEY_SIZE] = { 0x76,0x65,0x72,0x79,0x6e,0x69,0x63,0x65,
                                     0x70,0x61,0x73,0x73,0x77,0x6f,0x72,0x64,
                                     0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38};
#else
    unsigned char   key[DES3_KEY_SIZE] = { 0x76, 0xc9, 0xcb, 0xc6, 0xed, 0x18, 0xb2,
0x70, 0xc1, 0xcb, 0x97, 0x6d, 0xdc, 0xb2,
0x30, 0x64, 0xc9, 0xa3, 0x46, 0xcd, 0x9c
};
#endif
                                     
    /*initialization vector: 8 bytes: "mysecret"*/
    unsigned char   ive[DES_BLOCK_SIZE] = { 0x6d,0x79,0x73,0x65,0x63,0x72,0x65,0x74 };
        
    /*result holding the example max length array*/
    unsigned char   output[sizeof(des3_test_msg)-1];
	
	DES_t des;

	length = strlen((const char *)des3_test_msg);
      
	//encrypt
	DES_Init(&des, DES_3, key, ive);
	DES_Encrypt(&des, des3_test_msg, output, length);
    
	//compare encrypted info
	if( compare_arrays(output,des3_encrypted,length) != 0 )
		printf("DES encryption error\n\r");
       
	//decrypt
	DES_Init(&des, DES_3, key, ive);
	DES_Decrypt(&des, des3_encrypted, output, length);

	//compare decrypted info
	if( compare_arrays(output,des3_test_msg,length) != 0)
		printf("3DES algorithm is NOT working as expected\n\r");
    
    printf("3DES test completed\n");
       
}

//=============================================================================
// SHA256 tests
//=============================================================================
typedef struct
{
  unsigned char *input;/*input array*/
  unsigned int output[8];/*expected result*/
} HashSHA256Test;

/*FSL: testcases*/
static const HashSHA256Test sha256_test[] =
{
  {(unsigned char*)"",{0xe3b0c442,0x98fc1c14,0x9afbf4c8,0x996fb924,0x27ae41e4,0x649b934c,0xa495991b,0x7852b855}},
  {(unsigned char*)"abc",{0xba7816bf,0x8f01cfea,0x414140de,0x5dae2223,0xb00361a3,0x96177a9c,0xb410ff61,0xf20015ad}},
  {(unsigned char*)"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",{0x248d6a61,0xd20638b8,0xe5c02693,0x0c3e6039,0xa33ce459,0x64ff2167,0xf6ecedd4,0x19db06c1}},
  {(unsigned char*)"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",{0xcf5b16a7,0x78af8380,0x036ce59e,0x7b049237,0x0b249b11,0xe8f07a51,0xafac4503,0x7afee9d1}},
  {(unsigned char*)"This is exactly 64 bytes long, not counting the terminating byte",{0xab64eff7,0xe88e2e46,0x165e29f2,0xbce41826,0xbd4c7b35,0x52f6b382,0xa9e7d3af,0x47c245f8}},
  {(unsigned char*)"For this sample, this 63-byte string will be used as input data",{0xf08a78cb,0xbaee082b,0x052ae070,0x8f32fa1e,0x50c5c421,0xaa772ba5,0xdbb406a2,0xea6be342}},
  {(unsigned char*)"And this textual data, astonishing as it may appear, is exactly 128 bytes in length, as are both SHA-384 and SHA-512 block sizes",{0x0ab80334,0x4830f920,0x89494fb6,0x35ad00d7,0x6164ad6e,0x57012b23,0x7722df0d,0x7ad26896}},
  {(unsigned char*)"By hashing data that is one byte less than a multiple of a hash block length (like this 127-byte string), bugs may be revealed.",{0xe4326d04,0x59653d7d,0x3514674d,0x713e74dc,0x3df11ed4,0xd30b4013,0xfd327fdb,0x9e394c26}},
  {(unsigned char*)"The quick brown fox jumps over the lazy dog",{0xd7a8fbb3,0x07d78094,0x69ca9abc,0xb0082e4f,0x8d5651e4,0x6d3cdb76,0x2d02d0bf,0x37c9e592}},
  {(unsigned char*)"This test tries to use the n-block utility from the hash library and as a matter of fact we're trying to get only 128 characters",{0x2ce675bd,0x3b70e104,0xd696d1b2,0x5bf3d42b,0x2b45cd77,0x6d4f590f,0x210f12c4,0x4bf473d5}},
};

/*FSL: new test cases*/
static const unsigned int sha256_result1[] = {0xf8c21c3f,0x5f3f5198,0xb22f97d3,0x0e33e341,0x000f6cbc,0x64e79716,0xcaf2c249,0xf77bd8be};
static const unsigned int sha256_result2[] = {0xe3b0c442,0x98fc1c14,0x9afbf4c8,0x996fb924,0x27ae41e4,0x649b934c,0xa495991b,0x7852b855};

/*
 * sha256_main: performs SHA256 test using CAU
 */
#define SHA256_RESULT_LENGTH SHA256_BYTES_SIZE
#define CRYPTO_BLOCK_LENGTH HASH_BLOCK_SIZE
#define SHA256_TEST_CASES      sizeof(sha256_test)/sizeof(sha256_test[0])
static void 
sha256_main(void)
{
    unsigned int sha256_result[SHA256_RESULT_LENGTH/4];
    unsigned char *sha256_padded;
    unsigned int i, blocks, length;
    
    unsigned char *p,*q, pad[CRYPTO_BLOCK_LENGTH];
    
	Hash_t sha256;
	uint8_t digest[SHA256_BYTES_SIZE];
	int cnt, idx;

    /*************************************************************************/
    
    /*Testing cau_sha256_update()*/
    for(i=0;i<SHA256_TEST_CASES;i++)
    {
      /*get string length*/
      length = strlen((char const *)sha256_test[i].input);

	  Hash_Init(&sha256, HASH_SHA256);
	  Hash_Update(&sha256, sha256_test[i].input, length);
	  Hash_GetDigest(&sha256, digest);

	  for (cnt = 0, idx = 0; cnt < SHA256_BYTES_SIZE; cnt += 4, idx ++) {
		  sha256_result[idx] = ((uint32_t)digest[cnt] << 24)
			  | ((uint32_t)digest[cnt + 1] << 16)
			  | ((uint32_t)digest[cnt + 2] << 8)
			  | ((uint32_t)digest[cnt + 3]);
	  }

      if( compare_arrays((unsigned char *)sha256_result,(unsigned char *)sha256_test[i].output,SHA256_RESULT_LENGTH) )
        printf("Error during SHA256 testcase %d\n",i);
	}

    /*************************************************************************/
    /*2nd Test*/
    p = (unsigned char*)"This test tries to use the n-block utility from the hash library";//64 bytes
    q = (unsigned char*)" and as a matter of fact we're trying to get only 128 characters, anyway we need to add 64 more bytes to finally get 192 bytes!!";//128 bytes
    /*sha256_result1 is the output*/

	Hash_Init(&sha256, HASH_SHA256);
	Hash_Update(&sha256, p, strlen(p));
	Hash_Update(&sha256, q, strlen(q));
	Hash_GetDigest(&sha256, digest);
    
	for (cnt = 0, idx = 0; cnt < SHA256_BYTES_SIZE; cnt += 4, idx ++) {
		sha256_result[idx] = ((uint32_t)digest[cnt] << 24)
			| ((uint32_t)digest[cnt + 1] << 16)
			| ((uint32_t)digest[cnt + 2] << 8)
			| ((uint32_t)digest[cnt + 3]);
	}

    /*FSL: check if output matches with the precalculated result*/
    if( compare_arrays((unsigned char *)sha256_result,(unsigned char *)sha256_result1,SHA256_RESULT_LENGTH) )
        printf("Error during SHA256 testcase using cau_sha256_hash_n()\n");

    /*************************************************************************/
  
    /*3rd test*/
    
    /*using an empty string as test!*/
    
    /*sha256_result2 is the output*/
    
	Hash_Init(&sha256, HASH_SHA256);
	Hash_GetDigest(&sha256, digest);
    
	for (cnt = 0, idx = 0; cnt < SHA256_BYTES_SIZE; cnt += 4, idx ++) {
		sha256_result[idx] = ((uint32_t)digest[cnt] << 24)
			| ((uint32_t)digest[cnt + 1] << 16)
			| ((uint32_t)digest[cnt + 2] << 8)
			| ((uint32_t)digest[cnt + 3]);
	}
    
    /* FSL: Performs SHA256 hash algorithm for a single input message block*/
    /*FSL: check if output matches with the precalculated result*/
    if( compare_arrays((unsigned char *)sha256_result,(unsigned char *)sha256_result2,SHA256_RESULT_LENGTH) )
        printf("Error during SHA256 testcase using cau_sha256_hash()\n"); 

    /*************************************************************************/
    
    /*FSL: we are done!*/
    printf("SHA256 tests completed\n");
    
}


//=============================================================================
// SHA-1 tests
//=============================================================================

/*Note: FIPS 180-2 says SHA-1 and SHA-256 outputs are integers*/
/*
 * . . . the resulting 160-bit message digest of the message, M, is H0 | 
 * H1 | H2 | H3 | H4
 */

/*SHA1 online: http://www.functions-online.com/sha1.html*/

/*FSL: testcases*/
#define SHA1_TEST_CASES      sizeof(sha1_test)/sizeof(sha1_test[0])
#define SHA1_RESULT_LENGTH                     20
typedef struct
{
  unsigned char *input;/*input array*/
  unsigned int output[SHA1_RESULT_LENGTH/4];/*expected result*/
} HashSHA1Test;

static const HashSHA1Test sha1_test[] =
{
  {(unsigned char*)"",{0xda39a3ee,0x5e6b4b0d,0x3255bfef,0x95601890,0xafd80709}},
  {(unsigned char*)"a",{0x86f7e437,0xfaa5a7fc,0xe15d1ddc,0xb9eaeaea,0x377667b8}},
  {(unsigned char*)"abc",{0xa9993e36,0x4706816a,0xba3e2571,0x7850c26c,0x9cd0d89d}},
  {(unsigned char*)"message digest",{0xc12252ce,0xda8be899,0x4d5fa029,0x0a47231c,0x1d16aae3}},
  {(unsigned char*)"abcdefghijklmnopqrstuvwxyz",{0x32d10c7b,0x8cf96570,0xca04ce37,0xf2a19d84,0x240d3a89}},
  {(unsigned char*)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",{0x761c457b,0xf73b14d2,0x7e9e9265,0xc46f4b4d,0xda11f940}},
  {(unsigned char*)"12345678901234567890123456789012345678901234567890123456789012345678901234567890",{0x50abf570,0x6a150990,0xa08b2c5e,0xa40fa0e5,0x85554732}},
};

/*FSL: new test cases*/
static const unsigned int sha1_result1[] = {0xb7a1f498,0xdaf49dce,0x8fb714b4,0xc27fe1a1,0xee33150e};
static const unsigned int sha1_result2[] = {0xda39a3ee,0x5e6b4b0d,0x3255bfef,0x95601890,0xafd80709};

/*
 * sha1_main: performs SHA1 test using CAU
 */
static void 
sha1_main(void)
{
    unsigned int sha1_result[SHA1_RESULT_LENGTH/4];
    unsigned char *sha1_padded;
    unsigned int i, blocks, length;
    
    unsigned char *p,*q, pad[CRYPTO_BLOCK_LENGTH];
    
	Hash_t sha1;
	uint8_t digest[SHA1_BYTES_SIZE];
	int cnt, idx;

    /*************************************************************************/
    
    /*Testing cau_sha1_update()*/
    for(i=0;i<SHA1_TEST_CASES;i++)
    {
      /*get string length*/
      length = strlen((char const *)sha1_test[i].input);

	  Hash_Init(&sha1, HASH_SHA1);
	  Hash_Update(&sha1, sha1_test[i].input, length);
	  Hash_GetDigest(&sha1, digest);
      
	  for (cnt = 0, idx = 0; cnt < SHA1_BYTES_SIZE; cnt += 4, idx ++) {
		  sha1_result[idx] = ((uint32_t)digest[cnt] << 24)
			  | ((uint32_t)digest[cnt + 1] << 16)
			  | ((uint32_t)digest[cnt + 2] << 8)
			  | ((uint32_t)digest[cnt + 3]);
	  }

      if( compare_arrays((unsigned char *)sha1_result,(unsigned char *)sha1_test[i].output,SHA1_RESULT_LENGTH) )
        printf("Error during SHA1 testcase %d\n",i);
	} 

    /*************************************************************************/
    /*2nd Test*/
    p = (unsigned char*)"This test tries to use the n-block utility from the hash library";//64 bytes
    q = (unsigned char*)" and as a matter of fact we're trying to get only 128 characters, anyway we need to add 64 more bytes to finally get 192 bytes!!";//128 bytes
    /*sha1_result1 is the output*/
    
	Hash_Init(&sha1, HASH_SHA1);
	Hash_Update(&sha1, p, strlen(p));
	Hash_Update(&sha1, q, strlen(q));
	Hash_GetDigest(&sha1, digest);
      
	for (cnt = 0, idx = 0; cnt < SHA1_BYTES_SIZE; cnt += 4, idx ++) {
		sha1_result[idx] = ((uint32_t)digest[cnt] << 24)
			| ((uint32_t)digest[cnt + 1] << 16)
			| ((uint32_t)digest[cnt + 2] << 8)
			| ((uint32_t)digest[cnt + 3]);
	}
   
    /*FSL: check if output matches with the precalculated result*/
    if( compare_arrays((unsigned char *)sha1_result,(unsigned char *)sha1_result1,SHA1_RESULT_LENGTH) )
        printf("Error during SHA1 testcase using cau_sha1_hash_n()\n");

    /*************************************************************************/
  
    /*3rd test*/
    
    /*using an empty string as test!*/
    
    /*sha1_result2 is the output*/
    
	Hash_Init(&sha1, HASH_SHA1);
	Hash_GetDigest(&sha1, digest);
      
	for (cnt = 0, idx = 0; cnt < SHA1_BYTES_SIZE; cnt += 4, idx ++) {
		sha1_result[idx] = ((uint32_t)digest[cnt] << 24)
			| ((uint32_t)digest[cnt + 1] << 16)
			| ((uint32_t)digest[cnt + 2] << 8)
			| ((uint32_t)digest[cnt + 3]);
	}
    
    /*FSL: check if output matches with the precalculated result*/
    if( compare_arrays((unsigned char *)sha1_result,(unsigned char *)sha1_result2,SHA1_RESULT_LENGTH) )
        printf("Error during SHA1 testcase using cau_sha1_hash()\n");
    
    /*************************************************************************/
    
    /*FSL: we are done!*/
    printf("SHA1 tests completed\n");
    
}

//=============================================================================

/*
 * RFC-1321 specifically says MD5 outputs bytes in "little endian" order:
 *  The message digest produced as output is A, B, C, D. That is, we begin
 *  with the low-order byte of A, and end with the high-order byte of D.
 */

#define MD5_TEST_CASES      sizeof(md5_test)/sizeof(md5_test[0])
#define MD5_RESULT_LENGTH                     16

typedef struct
{
  unsigned char *input;/*input array*/
  unsigned char output[MD5_RESULT_LENGTH];/*expected result*/
} HashMD5Test;

/*MD5 online: http://www.functions-online.com/md5.html*/

/*FSL: testcases*/
static const HashMD5Test md5_test[] =
{
  {(unsigned char*)"",{0xd4,0x1d,0x8c,0xd9,0x8f,0x00,0xb2,0x04,0xe9,0x80,0x09,0x98,0xec,0xf8,0x42,0x7e}},
  {(unsigned char*)"a",{0x0c,0xc1,0x75,0xb9,0xc0,0xf1,0xb6,0xa8,0x31,0xc3,0x99,0xe2,0x69,0x77,0x26,0x61}},
  {(unsigned char*)"abc",{0x90,0x01,0x50,0x98,0x3c,0xd2,0x4f,0xb0,0xd6,0x96,0x3f,0x7d,0x28,0xe1,0x7f,0x72}},
  {(unsigned char*)"message digest",{0xf9,0x6b,0x69,0x7d,0x7c,0xb7,0x93,0x8d,0x52,0x5a,0x2f,0x31,0xaa,0xf1,0x61,0xd0}},
  {(unsigned char*)"abcdefghijklmnopqrstuvwxyz",{0xc3,0xfc,0xd3,0xd7,0x61,0x92,0xe4,0x00,0x7d,0xfb,0x49,0x6c,0xca,0x67,0xe1,0x3b}},
  {(unsigned char*)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",{0xd1,0x74,0xab,0x98,0xd2,0x77,0xd9,0xf5,0xa5,0x61,0x1c,0x2c,0x9f,0x41,0x9d,0x9f}},
  {(unsigned char*)"12345678901234567890123456789012345678901234567890123456789012345678901234567890",{0x57,0xed,0xf4,0xa2,0x2b,0xe3,0xc9,0x55,0xac,0x49,0xda,0x2e,0x21,0x07,0xb6,0x7a}},
};

/*FSL: new test cases*/
static const unsigned char md5_result1[] = {0xc3,0x1f,0x5e,0x69,0xdd,0x2e,0x5c,0xde,0x38,0x53,0x22,0x0e,0x60,0x1c,0x01,0xf1};
static const unsigned char md5_result2[] = {0xd4,0x1d,0x8c,0xd9,0x8f,0x00,0xb2,0x04,0xe9,0x80,0x09,0x98,0xec,0xf8,0x42,0x7e};

/*
 * md5_main: performs MD5 test using CAU
 */
static void 
md5_main(void)
{
    unsigned char md5_result[MD5_RESULT_LENGTH];
    unsigned char *md5_padded;
    unsigned int i, blocks, length;
    
    unsigned char *p,*q, pad[CRYPTO_BLOCK_LENGTH];
    
	Hash_t md5;
	uint8_t digest[MD5_BYTES_SIZE];
	int cnt, idx;

    /*************************************************************************/
    
    /*Testing cau_md5_update()*/
    for(i=0;i<MD5_TEST_CASES;i++)
    {
		Hash_Init(&md5, HASH_MD5);
		Hash_Update(&md5, md5_test[i].input, strlen(md5_test[i].input));
		Hash_GetDigest(&md5, md5_result);

		if( compare_arrays(md5_result, (uint8_t *)md5_test[i].output,MD5_RESULT_LENGTH) )
        printf("Error during MD5 testcase %d\n",i);
    } 

    /*************************************************************************/
    
    /*2nd Test*/
    p = (unsigned char*)"This test tries to use the n-block utility from the hash library";//64 bytes
    q = (unsigned char*)" and as a matter of fact we're trying to get only 128 characters, anyway we need to add 64 more bytes to finally get 192 bytes!!";//128 bytes
    /*md5_result1 is the output*/
    
	Hash_Init(&md5, HASH_MD5);
	Hash_Update(&md5, p, strlen(p));
	Hash_Update(&md5, q, strlen(q));
	Hash_GetDigest(&md5, md5_result);
    
    /*FSL: check if output matches with the precalculated result*/
    if( compare_arrays(md5_result,(uint8_t *)md5_result1,MD5_RESULT_LENGTH) )
        printf("Error during MD5 testcase using cau_md5_hash_n()\n");
    
    /*************************************************************************/
  
    /*3rd test*/
    
    /*using an empty string as test!*/
    
    /*md5_result2 is the output*/
    
	Hash_Init(&md5, HASH_MD5);
	Hash_GetDigest(&md5, md5_result);
    
    /*FSL: check if output matches with the precalculated result*/
    if( compare_arrays(md5_result,(uint8_t *)md5_result2,MD5_RESULT_LENGTH) )
        printf("Error during MD5 testcase using cau_md5_hash()\n");

    /*************************************************************************/
    
    /*FSL: we are done!*/
    printf("MD5 tests completed\n");
    
}


//=============================================================================
static const uint8_t certificate[] = {
0x30, 0x82, 0x07, 0x83, 0x30, 0x82, 0x06, 0x6b, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x3c,
0x8c, 0xe9, 0x50, 0x7b, 0x14, 0x46, 0xc4, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x49, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0a,
0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x49, 0x6e, 0x63, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03,
0x55, 0x04, 0x03, 0x13, 0x1c, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x49, 0x6e, 0x74, 0x65,
0x72, 0x6e, 0x65, 0x74, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x47,
0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x35, 0x30, 0x36, 0x31, 0x30, 0x30, 0x38, 0x30,
0x36, 0x5a, 0x17, 0x0d, 0x31, 0x35, 0x30, 0x38, 0x30, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
0x5a, 0x30, 0x66, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x43, 0x61, 0x6c, 0x69, 0x66,
0x6f, 0x72, 0x6e, 0x69, 0x61, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x0d,
0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x56, 0x69, 0x65, 0x77, 0x31, 0x13, 0x30,
0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x47, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x20, 0x49,
0x6e, 0x63, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x2a, 0x2e, 0x67,
0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06,
0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f,
0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0x9b, 0x79, 0x69, 0xb0, 0xa2, 0xe9,
0x1a, 0x37, 0xf9, 0x0e, 0xcc, 0xff, 0x6a, 0x41, 0x6c, 0x57, 0x19, 0xcd, 0x4f, 0x85, 0xe2, 0x8c,
0x0b, 0x9b, 0x50, 0xcb, 0x5e, 0xb5, 0x10, 0xef, 0x33, 0x7b, 0x54, 0x7d, 0x45, 0x43, 0xe7, 0x6a,
0x83, 0x00, 0x55, 0x8d, 0xdb, 0x91, 0x0e, 0x6f, 0xe7, 0x30, 0xfd, 0x2a, 0xe8, 0x01, 0x0d, 0x4c,
0xd2, 0xf0, 0xc3, 0x95, 0x29, 0x8f, 0x6f, 0x1b, 0xe4, 0x07, 0x00, 0xd4, 0x74, 0x62, 0x50, 0x8f,
0x44, 0xae, 0x58, 0x6f, 0x5b, 0x4c, 0x3e, 0x30, 0x34, 0xd3, 0x6f, 0xab, 0x0d, 0x64, 0xad, 0x5c,
0x06, 0xb7, 0xec, 0x25, 0xda, 0x14, 0x25, 0x61, 0xc9, 0xb2, 0x7c, 0x54, 0x05, 0xa7, 0x47, 0xce,
0x39, 0x7a, 0x0b, 0x3b, 0x83, 0x68, 0x0c, 0xbb, 0xcd, 0x7c, 0xa8, 0x5d, 0xca, 0x51, 0xc3, 0x27,
0x61, 0xb4, 0x27, 0xcb, 0x25, 0x7c, 0xf6, 0x05, 0xdb, 0x80, 0xea, 0x83, 0x7a, 0x63, 0xe4, 0x3b,
0xfb, 0x95, 0xa3, 0x93, 0x69, 0xc1, 0x39, 0x9b, 0x53, 0xc7, 0xea, 0xa6, 0x29, 0x45, 0x3f, 0xbd,
0x58, 0xb4, 0xdc, 0x10, 0x1e, 0x2e, 0xba, 0x99, 0x24, 0xd9, 0xf5, 0x03, 0xed, 0xc8, 0xdc, 0xe6,
0x0b, 0x7f, 0x1a, 0x4a, 0x18, 0x89, 0x8d, 0xd7, 0x52, 0xe0, 0x9e, 0xc6, 0xa3, 0x72, 0xcd, 0x62,
0x13, 0xf6, 0x4c, 0x57, 0x55, 0xb6, 0xfb, 0x5e, 0xdb, 0x00, 0x43, 0x8d, 0xb8, 0xee, 0x6c, 0x45,
0x70, 0x2a, 0x96, 0xfc, 0x4c, 0xad, 0x74, 0x57, 0x5a, 0x58, 0x1f, 0x48, 0xdf, 0x0c, 0x03, 0xdd,
0x2a, 0xd4, 0xb8, 0x44, 0x68, 0xbc, 0x18, 0x09, 0xd3, 0xa2, 0xfc, 0x39, 0xc1, 0x44, 0x1c, 0xcb,
0x3f, 0xb9, 0x28, 0x18, 0x54, 0xe0, 0xe1, 0x84, 0xf8, 0xbc, 0x1f, 0x27, 0x29, 0xf5, 0x1c, 0x32,
0x7f, 0xf1, 0x5d, 0xc7, 0x02, 0x22, 0x59, 0x12, 0x8a, 0xb7, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3,
0x82, 0x04, 0x50, 0x30, 0x82, 0x04, 0x4c, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x16,
0x30, 0x14, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2b, 0x06,
0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x82, 0x03, 0x26, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x04,
0x82, 0x03, 0x1d, 0x30, 0x82, 0x03, 0x19, 0x82, 0x0c, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0d, 0x2a, 0x2e, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64,
0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x16, 0x2a, 0x2e, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x67, 0x69, 0x6e,
0x65, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x12, 0x2a, 0x2e,
0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d,
0x82, 0x16, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2d, 0x61, 0x6e, 0x61, 0x6c, 0x79,
0x74, 0x69, 0x63, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
0x6c, 0x65, 0x2e, 0x63, 0x61, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
0x63, 0x6c, 0x82, 0x0e, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x2e,
0x69, 0x6e, 0x82, 0x0e, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x2e,
0x6a, 0x70, 0x82, 0x0e, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x2e,
0x75, 0x6b, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d,
0x2e, 0x61, 0x72, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f,
0x6d, 0x2e, 0x61, 0x75, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63,
0x6f, 0x6d, 0x2e, 0x62, 0x72, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
0x63, 0x6f, 0x6d, 0x2e, 0x63, 0x6f, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x6d, 0x78, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x74, 0x72, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x6e, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f,
0x67, 0x6c, 0x65, 0x2e, 0x64, 0x65, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
0x2e, 0x65, 0x73, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x66, 0x72,
0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x68, 0x75, 0x82, 0x0b, 0x2a,
0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x69, 0x74, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f,
0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x6e, 0x6c, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
0x65, 0x2e, 0x70, 0x6c, 0x82, 0x0b, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
0x74, 0x82, 0x12, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x61, 0x64, 0x61, 0x70, 0x69,
0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0f, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x61,
0x70, 0x69, 0x73, 0x2e, 0x63, 0x6e, 0x82, 0x14, 0x2a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x72, 0x63, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x11, 0x2a, 0x2e,
0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x2e, 0x63, 0x6f, 0x6d, 0x82,
0x0c, 0x2a, 0x2e, 0x67, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x2e, 0x63, 0x6e, 0x82, 0x0d, 0x2a,
0x2e, 0x67, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0a, 0x2a, 0x2e,
0x67, 0x76, 0x74, 0x31, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0a, 0x2a, 0x2e, 0x67, 0x76, 0x74, 0x32,
0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x14, 0x2a, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x2e, 0x67,
0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0c, 0x2a, 0x2e, 0x75, 0x72,
0x63, 0x68, 0x69, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x10, 0x2a, 0x2e, 0x75, 0x72, 0x6c, 0x2e,
0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x16, 0x2a, 0x2e, 0x79, 0x6f,
0x75, 0x74, 0x75, 0x62, 0x65, 0x2d, 0x6e, 0x6f, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65, 0x2e, 0x63,
0x6f, 0x6d, 0x82, 0x0d, 0x2a, 0x2e, 0x79, 0x6f, 0x75, 0x74, 0x75, 0x62, 0x65, 0x2e, 0x63, 0x6f,
0x6d, 0x82, 0x16, 0x2a, 0x2e, 0x79, 0x6f, 0x75, 0x74, 0x75, 0x62, 0x65, 0x65, 0x64, 0x75, 0x63,
0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0b, 0x2a, 0x2e, 0x79, 0x74, 0x69,
0x6d, 0x67, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0b, 0x61, 0x6e, 0x64, 0x72, 0x6f, 0x69, 0x64, 0x2e,
0x63, 0x6f, 0x6d, 0x82, 0x04, 0x67, 0x2e, 0x63, 0x6f, 0x82, 0x06, 0x67, 0x6f, 0x6f, 0x2e, 0x67,
0x6c, 0x82, 0x14, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2d, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74,
0x69, 0x63, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0a, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
0x63, 0x6f, 0x6d, 0x82, 0x12, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
0x72, 0x63, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x0a, 0x75, 0x72, 0x63, 0x68, 0x69, 0x6e, 0x2e,
0x63, 0x6f, 0x6d, 0x82, 0x08, 0x79, 0x6f, 0x75, 0x74, 0x75, 0x2e, 0x62, 0x65, 0x82, 0x0b, 0x79,
0x6f, 0x75, 0x74, 0x75, 0x62, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x14, 0x79, 0x6f, 0x75, 0x74,
0x75, 0x62, 0x65, 0x65, 0x64, 0x75, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x63, 0x6f, 0x6d,
0x30, 0x68, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x5c, 0x30, 0x5a,
0x30, 0x2b, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x1f, 0x68, 0x74,
0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x70, 0x6b, 0x69, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
0x63, 0x6f, 0x6d, 0x2f, 0x47, 0x49, 0x41, 0x47, 0x32, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x2b, 0x06,
0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x1f, 0x68, 0x74, 0x74, 0x70, 0x3a,
0x2f, 0x2f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x31, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6f, 0x63, 0x73, 0x70, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d,
0x0e, 0x04, 0x16, 0x04, 0x14, 0xcd, 0xd8, 0x67, 0x63, 0xa6, 0x47, 0xb2, 0x96, 0x24, 0xd2, 0x49,
0x81, 0x99, 0xbb, 0x41, 0x0e, 0x3e, 0xac, 0x06, 0xfc, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,
0x01, 0x01, 0xff, 0x04, 0x02, 0x30, 0x00, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18,
0x30, 0x16, 0x80, 0x14, 0x4a, 0xdd, 0x06, 0x16, 0x1b, 0xbc, 0xf6, 0x68, 0xb5, 0x76, 0xf5, 0x81,
0xb6, 0xbb, 0x62, 0x1a, 0xba, 0x5a, 0x81, 0x2f, 0x30, 0x17, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04,
0x10, 0x30, 0x0e, 0x30, 0x0c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xd6, 0x79, 0x02, 0x05,
0x01, 0x30, 0x30, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x29, 0x30, 0x27, 0x30, 0x25, 0xa0, 0x23,
0xa0, 0x21, 0x86, 0x1f, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x70, 0x6b, 0x69, 0x2e, 0x67,
0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x47, 0x49, 0x41, 0x47, 0x32, 0x2e,
0x63, 0x72, 0x6c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05,
0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x78, 0x46, 0x6c, 0x86, 0x74, 0xd6, 0x19, 0x97, 0xa8,
0x38, 0x35, 0x83, 0x8f, 0x9f, 0xeb, 0x8a, 0x16, 0xe4, 0x84, 0x11, 0x42, 0xe3, 0xa6, 0x57, 0x39,
0x62, 0x7f, 0xda, 0x2e, 0xd2, 0x2f, 0xd8, 0x62, 0x51, 0x52, 0xdc, 0x17, 0xe1, 0xb7, 0xfd, 0xb5,
0xec, 0x0a, 0x7e, 0xcf, 0x1b, 0x9d, 0x53, 0x28, 0x89, 0x36, 0x5e, 0xd3, 0x98, 0x81, 0x83, 0x05,
0x26, 0x25, 0x95, 0x5e, 0x7b, 0x2d, 0xd5, 0xd1, 0x5b, 0x74, 0xab, 0xcd, 0x3a, 0x62, 0xe5, 0x18,
0x48, 0xf4, 0x95, 0x22, 0x59, 0x4e, 0x8e, 0x6c, 0xb9, 0x39, 0x15, 0x4f, 0x60, 0x23, 0x19, 0xcc,
0x51, 0xb7, 0x89, 0xbc, 0x6e, 0x8b, 0x62, 0xb5, 0x1d, 0xd2, 0x20, 0xc8, 0x02, 0x7b, 0x23, 0x02,
0x40, 0x5c, 0x5e, 0xec, 0x8c, 0x6c, 0xe0, 0x44, 0xc2, 0x95, 0x18, 0x4f, 0xf1, 0x41, 0x74, 0xbc,
0x13, 0x81, 0xd1, 0x19, 0xc9, 0x1d, 0xb5, 0x49, 0x4b, 0x8d, 0x42, 0x2a, 0x40, 0xb2, 0x0d, 0x1a,
0x02, 0xd3, 0xea, 0xb9, 0xc0, 0x57, 0x10, 0x69, 0x39, 0x61, 0xb6, 0x38, 0x99, 0xcc, 0xfe, 0xce,
0xda, 0xac, 0x1b, 0x32, 0xc9, 0x46, 0x2a, 0xf5, 0x2e, 0x3b, 0x02, 0x02, 0x96, 0xc3, 0xa0, 0xd3,
0x09, 0x93, 0x49, 0xb2, 0x46, 0xbb, 0x3e, 0xb3, 0xe3, 0x5c, 0xe4, 0xc0, 0xa3, 0x7d, 0x21, 0x2d,
0xc9, 0x53, 0x5a, 0x5e, 0x61, 0x43, 0x6c, 0xb3, 0xf6, 0x8e, 0xaa, 0x26, 0xca, 0x9c, 0x9e, 0x74,
0xa0, 0xbb, 0xe9, 0xec, 0xab, 0xdf, 0x23, 0x63, 0xa2, 0x63, 0xc3, 0xe4, 0xa0, 0x79, 0xf9, 0xb3,
0x58, 0xd7, 0xd4, 0x94, 0x74, 0xdd, 0xeb, 0x3d, 0xf4, 0x79, 0xc4, 0x4d, 0x0d, 0x97, 0x44, 0x9e,
0x96, 0x6d, 0xca, 0x75, 0xbd, 0xbe, 0xe7, 0x36, 0x3e, 0xe0, 0x58, 0x93, 0x47, 0x13, 0xa2, 0xea,
0x27, 0x84, 0x9a, 0x37, 0x18, 0xf6, 0x5b
};


/******************************** END-OF-FILE ********************************/
